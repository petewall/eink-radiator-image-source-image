// Code generated by counterfeiter. DO NOT EDIT.
package internalfakes

import (
	"image/color"
	"io"
	"sync"

	"github.com/petewall/eink-radiator-image-source-image/v2/internal"
)

type FakeImageContext struct {
	DrawRectangleStub        func(float64, float64, float64, float64)
	drawRectangleMutex       sync.RWMutex
	drawRectangleArgsForCall []struct {
		arg1 float64
		arg2 float64
		arg3 float64
		arg4 float64
	}
	EncodePNGStub        func(io.Writer) error
	encodePNGMutex       sync.RWMutex
	encodePNGArgsForCall []struct {
		arg1 io.Writer
	}
	encodePNGReturns struct {
		result1 error
	}
	encodePNGReturnsOnCall map[int]struct {
		result1 error
	}
	FillStub        func()
	fillMutex       sync.RWMutex
	fillArgsForCall []struct {
	}
	SavePNGStub        func(string) error
	savePNGMutex       sync.RWMutex
	savePNGArgsForCall []struct {
		arg1 string
	}
	savePNGReturns struct {
		result1 error
	}
	savePNGReturnsOnCall map[int]struct {
		result1 error
	}
	SetColorStub        func(color.Color)
	setColorMutex       sync.RWMutex
	setColorArgsForCall []struct {
		arg1 color.Color
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImageContext) DrawRectangle(arg1 float64, arg2 float64, arg3 float64, arg4 float64) {
	fake.drawRectangleMutex.Lock()
	fake.drawRectangleArgsForCall = append(fake.drawRectangleArgsForCall, struct {
		arg1 float64
		arg2 float64
		arg3 float64
		arg4 float64
	}{arg1, arg2, arg3, arg4})
	stub := fake.DrawRectangleStub
	fake.recordInvocation("DrawRectangle", []interface{}{arg1, arg2, arg3, arg4})
	fake.drawRectangleMutex.Unlock()
	if stub != nil {
		fake.DrawRectangleStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeImageContext) DrawRectangleCallCount() int {
	fake.drawRectangleMutex.RLock()
	defer fake.drawRectangleMutex.RUnlock()
	return len(fake.drawRectangleArgsForCall)
}

func (fake *FakeImageContext) DrawRectangleCalls(stub func(float64, float64, float64, float64)) {
	fake.drawRectangleMutex.Lock()
	defer fake.drawRectangleMutex.Unlock()
	fake.DrawRectangleStub = stub
}

func (fake *FakeImageContext) DrawRectangleArgsForCall(i int) (float64, float64, float64, float64) {
	fake.drawRectangleMutex.RLock()
	defer fake.drawRectangleMutex.RUnlock()
	argsForCall := fake.drawRectangleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeImageContext) EncodePNG(arg1 io.Writer) error {
	fake.encodePNGMutex.Lock()
	ret, specificReturn := fake.encodePNGReturnsOnCall[len(fake.encodePNGArgsForCall)]
	fake.encodePNGArgsForCall = append(fake.encodePNGArgsForCall, struct {
		arg1 io.Writer
	}{arg1})
	stub := fake.EncodePNGStub
	fakeReturns := fake.encodePNGReturns
	fake.recordInvocation("EncodePNG", []interface{}{arg1})
	fake.encodePNGMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImageContext) EncodePNGCallCount() int {
	fake.encodePNGMutex.RLock()
	defer fake.encodePNGMutex.RUnlock()
	return len(fake.encodePNGArgsForCall)
}

func (fake *FakeImageContext) EncodePNGCalls(stub func(io.Writer) error) {
	fake.encodePNGMutex.Lock()
	defer fake.encodePNGMutex.Unlock()
	fake.EncodePNGStub = stub
}

func (fake *FakeImageContext) EncodePNGArgsForCall(i int) io.Writer {
	fake.encodePNGMutex.RLock()
	defer fake.encodePNGMutex.RUnlock()
	argsForCall := fake.encodePNGArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageContext) EncodePNGReturns(result1 error) {
	fake.encodePNGMutex.Lock()
	defer fake.encodePNGMutex.Unlock()
	fake.EncodePNGStub = nil
	fake.encodePNGReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImageContext) EncodePNGReturnsOnCall(i int, result1 error) {
	fake.encodePNGMutex.Lock()
	defer fake.encodePNGMutex.Unlock()
	fake.EncodePNGStub = nil
	if fake.encodePNGReturnsOnCall == nil {
		fake.encodePNGReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.encodePNGReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImageContext) Fill() {
	fake.fillMutex.Lock()
	fake.fillArgsForCall = append(fake.fillArgsForCall, struct {
	}{})
	stub := fake.FillStub
	fake.recordInvocation("Fill", []interface{}{})
	fake.fillMutex.Unlock()
	if stub != nil {
		fake.FillStub()
	}
}

func (fake *FakeImageContext) FillCallCount() int {
	fake.fillMutex.RLock()
	defer fake.fillMutex.RUnlock()
	return len(fake.fillArgsForCall)
}

func (fake *FakeImageContext) FillCalls(stub func()) {
	fake.fillMutex.Lock()
	defer fake.fillMutex.Unlock()
	fake.FillStub = stub
}

func (fake *FakeImageContext) SavePNG(arg1 string) error {
	fake.savePNGMutex.Lock()
	ret, specificReturn := fake.savePNGReturnsOnCall[len(fake.savePNGArgsForCall)]
	fake.savePNGArgsForCall = append(fake.savePNGArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SavePNGStub
	fakeReturns := fake.savePNGReturns
	fake.recordInvocation("SavePNG", []interface{}{arg1})
	fake.savePNGMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImageContext) SavePNGCallCount() int {
	fake.savePNGMutex.RLock()
	defer fake.savePNGMutex.RUnlock()
	return len(fake.savePNGArgsForCall)
}

func (fake *FakeImageContext) SavePNGCalls(stub func(string) error) {
	fake.savePNGMutex.Lock()
	defer fake.savePNGMutex.Unlock()
	fake.SavePNGStub = stub
}

func (fake *FakeImageContext) SavePNGArgsForCall(i int) string {
	fake.savePNGMutex.RLock()
	defer fake.savePNGMutex.RUnlock()
	argsForCall := fake.savePNGArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageContext) SavePNGReturns(result1 error) {
	fake.savePNGMutex.Lock()
	defer fake.savePNGMutex.Unlock()
	fake.SavePNGStub = nil
	fake.savePNGReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeImageContext) SavePNGReturnsOnCall(i int, result1 error) {
	fake.savePNGMutex.Lock()
	defer fake.savePNGMutex.Unlock()
	fake.SavePNGStub = nil
	if fake.savePNGReturnsOnCall == nil {
		fake.savePNGReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.savePNGReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeImageContext) SetColor(arg1 color.Color) {
	fake.setColorMutex.Lock()
	fake.setColorArgsForCall = append(fake.setColorArgsForCall, struct {
		arg1 color.Color
	}{arg1})
	stub := fake.SetColorStub
	fake.recordInvocation("SetColor", []interface{}{arg1})
	fake.setColorMutex.Unlock()
	if stub != nil {
		fake.SetColorStub(arg1)
	}
}

func (fake *FakeImageContext) SetColorCallCount() int {
	fake.setColorMutex.RLock()
	defer fake.setColorMutex.RUnlock()
	return len(fake.setColorArgsForCall)
}

func (fake *FakeImageContext) SetColorCalls(stub func(color.Color)) {
	fake.setColorMutex.Lock()
	defer fake.setColorMutex.Unlock()
	fake.SetColorStub = stub
}

func (fake *FakeImageContext) SetColorArgsForCall(i int) color.Color {
	fake.setColorMutex.RLock()
	defer fake.setColorMutex.RUnlock()
	argsForCall := fake.setColorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageContext) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.drawRectangleMutex.RLock()
	defer fake.drawRectangleMutex.RUnlock()
	fake.encodePNGMutex.RLock()
	defer fake.encodePNGMutex.RUnlock()
	fake.fillMutex.RLock()
	defer fake.fillMutex.RUnlock()
	fake.savePNGMutex.RLock()
	defer fake.savePNGMutex.RUnlock()
	fake.setColorMutex.RLock()
	defer fake.setColorMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImageContext) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ internal.ImageContext = new(FakeImageContext)
